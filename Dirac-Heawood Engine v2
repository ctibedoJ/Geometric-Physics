#!/usr/bin/env python3
"""
THE BETA-TRIAD TOPOLOGICAL ENGINE (FULL SUITE)
Lattice Field Theory on the Fano Plane (Heawood Graph)

Core Physics:
1. Geometry: Heawood Graph (Incidence Graph of PG(2,2))
2. Operator: Discrete Dirac Hamiltonian
3. Topology: Jackiw-Rebbi Domain Wall (Mass Inversion)
4. Proof A:  Robust Zero-Energy Mode (Topological Protection)
5. Proof B:  Adiabatic Spectral Flow (Phase Transition Verification)

Charles Tibedo | Beta-TRIAD Framework | 2026
"""

import numpy as np
import matplotlib.pyplot as plt
import scipy.linalg
import seaborn as sns

# --- GEOMETRIC CORE ---

class FanoGeometry:
    """
    Generates the exact combinatorial structure of the Fano Plane.
    """
    @staticmethod
    def incidence_matrix():
        """
        Returns the 7x7 Incidence Matrix C of PG(2,2).
        Rows = Points (0..6), Cols = Lines (0..6).
        Generated via Difference Set {0, 1, 3} mod 7.
        """
        incidence = np.zeros((7, 7))
        base_line = [0, 1, 3]
        for i in range(7):
            # Cyclic shift generates the 7 lines
            line_points = [(p + i) % 7 for p in base_line]
            incidence[i, line_points] = 1
        return incidence.T # Transpose to map Lines -> Points

class DiracLattice:
    """
    The Physical Universe Engine.
    Constructs the Hamiltonian H = Kinetic + Mass.
    """
    def __init__(self, mass_vector=None, mass_magnitude=1.5, noise_level=0.0):
        self.size = 14 # 7 Points + 7 Lines
        self.noise = noise_level
        self.C = FanoGeometry.incidence_matrix()
        
        # 1. BUILD THE MASS PROFILE
        if mass_vector is not None:
            # Custom profile for Adiabatic Evolution
            self.mass_vector = np.array(mass_vector)
        else:
            # Standard Domain Wall Construction
            # Nodes 0-3: Positive Mass (+m) -> "Vacuum A"
            # Nodes 4-6: Negative Mass (-m) -> "Vacuum B"
            self.m0 = mass_magnitude
            self.mass_vector = np.array([self.m0]*4 + [-self.m0]*3)
        
        # Inject Mass Disorder (if requested)
        if self.noise > 0:
            self.mass_vector += np.random.normal(0, self.noise, 7)
            
        M_matrix = np.diag(self.mass_vector)
        
        # 2. BUILD THE KINETIC HOPPING (The Adjacency)
        # Inject Bond Disorder (if requested) to test topological protection
        coupling_noise = np.zeros((7, 7))
        if self.noise > 0:
            coupling_noise = np.random.normal(0, self.noise, (7, 7))
        
        C_noisy = self.C + coupling_noise
        
        # 3. CONSTRUCT DIRAC HAMILTONIAN
        # H = [  M      C  ]
        #     [  C^T   -M  ]
        # This is the Chiral Dirac Operator on the Bipartite Graph.
        
        zero_7 = np.zeros((7, 7))
        
        # Off-diagonal blocks (Kinetic / Geometry)
        H_kinetic = np.block([
            [zero_7, C_noisy],
            [C_noisy.T, zero_7]
        ])
        
        # Diagonal blocks (Mass / Inertia)
        # Note: -M on the "Lines" sector preserves Chiral Symmetry logic
        H_mass = np.block([
            [M_matrix, zero_7],
            [zero_7, -M_matrix]
        ])
        
        self.H = H_kinetic + H_mass
        
        # 4. SOLVE THE UNIVERSE
        # Compute all energy levels (Eigenvalues) and states (Eigenvectors)
        self.evals, self.evecs = np.linalg.eigh(self.H)
        
        # Sort descending by energy
        idx = self.evals.argsort()[::-1]
        self.evals = self.evals[idx]
        self.evecs = self.evecs[:, idx]

    def get_zero_mode(self):
        """Finds the state closest to E=0 (The Mid-Gap State)"""
        idx_min = np.argmin(np.abs(self.evals))
        return self.evals[idx_min], self.evecs[:, idx_min]

# --- SIMULATION & PROOF ---

def run_proof():
    print("="*60)
    print("BETA-TRIAD: TOPOLOGICAL DIRAC ENGINE")
    print("Simulating Fano Plane with Jackiw-Rebbi Domain Wall")
    print("="*60)

    # 1. THE CLEAN UNIVERSE (Ideal Geometry)
    print("\n[PHASE 1] Computing Ideal Geometry...")
    clean_sim = DiracLattice(mass_magnitude=2.0, noise_level=0.0)
    e_zero, psi_zero = clean_sim.get_zero_mode()
    
    gap_limit = np.sqrt(2 + 2.0**2) # Theoretical bulk gap
    print(f"Theoretical Bulk Gap: +/- {gap_limit:.4f}")
    print(f"Measured Zero Mode:   E = {e_zero:.8f}")
    
    if abs(e_zero) < 1e-5:
        print(">> SUCCESS: Zero-Energy Mode Detected.")
    else:
        print(">> FAILURE: Gap is empty.")

    # 2. THE STRESS TEST (Topological Robustness)
    noise_amp = 0.35 # 35% Noise is HUGE in physics terms
    trials = 100
    print(f"\n[PHASE 2] Robustness Stress Test ({trials} Universes)")
    print(f"Injecting {noise_amp*100}% random noise into Mass and Bonds...")
    
    zero_energies = []
    bulk_energies = []
    
    for i in range(trials):
        noisy_sim = DiracLattice(mass_magnitude=2.0, noise_level=noise_amp)
        e_z, _ = noisy_sim.get_zero_mode()
        zero_energies.append(e_z)
        # Track the lowest POSITIVE bulk state (usually index 5)
        # We look for the first state above the zero mode
        bulk_idx = 5 if noisy_sim.evals[5] > 0 else 4
        bulk_energies.append(noisy_sim.evals[bulk_idx]) 

    z_mean = np.mean(np.abs(zero_energies))
    z_std = np.std(zero_energies)
    b_mean = np.mean(np.abs(bulk_energies))
    
    print(f"Zero Mode Mean Energy: {z_mean:.4f} +/- {z_std:.4f}")
    print(f"Bulk Mode Mean Energy: {b_mean:.4f}")
    
    protection_ratio = b_mean / (z_mean + 1e-9)
    print(f"Protection Factor:     {protection_ratio:.1f}x")
    
    if protection_ratio > 10:
        print(">> CONCLUSION: STATE IS TOPOLOGICALLY PROTECTED.")
    else:
        print(">> CONCLUSION: STATE IS ACCIDENTAL.")

    # 3. THE ADIABATIC PROOF (Spectral Flow)
    print(f"\n[PHASE 3] Adiabatic Spectral Flow (Topology Check)")
    print("Interpolating: Domain Wall (Topological) -> Uniform Mass (Trivial)")
    
    m_mag = 2.0
    mass_start = np.array([m_mag]*4 + [-m_mag]*3) # Domain Wall
    mass_end = np.array([m_mag]*7) # Trivial Uniform
    
    steps = 50
    lambdas = np.linspace(0, 1, steps)
    flow_data = []
    
    for lam in lambdas:
        # Linear Morphing
        current_mass = (1 - lam) * mass_start + lam * mass_end
        flow_sim = DiracLattice(mass_vector=current_mass)
        flow_data.append(flow_sim.evals)
        
    flow_data = np.array(flow_data)

    # --- VISUALIZATION ---
    plot_results(clean_sim, zero_energies, bulk_energies, noise_amp, lambdas, flow_data)

def plot_results(clean_sim, zero_hist, bulk_hist, noise_amp, flow_x, flow_y):
    plt.figure(figsize=(16, 12))
    sns.set_style("whitegrid")

    # PLOT A: THE CLEAN SPECTRUM
    plt.subplot(2, 2, 1)
    x = np.arange(14)
    plt.stem(x, clean_sim.evals, linefmt='k-', markerfmt='ko', basefmt=" ")
    
    # Highlight Zero Mode
    mid = 7
    plt.plot(mid-0.5, 0, 'ro', markersize=12, label='Zero Mode')
    plt.plot(mid-1.5, 0, 'ro', markersize=12) # Symmetry pair
    
    plt.axhline(0, color='r', linestyle='--', alpha=0.3)
    plt.title("A. The Spectrum of Reality (Clean)", fontsize=12, fontweight='bold')
    plt.ylabel("Energy Eigenvalue (E)")
    plt.xlabel("Mode Index")
    plt.legend()

    # PLOT B: WAVEFUNCTION LOCALIZATION
    plt.subplot(2, 2, 2)
    _, psi = clean_sim.get_zero_mode()
    prob_density = np.abs(psi)**2
    
    colors = ['firebrick']*4 + ['royalblue']*3 + ['gray']*7 # Points then Lines
    x_nodes = np.arange(7) 
    
    plt.bar(x_nodes, prob_density[:7], color=colors[:7], alpha=0.8)
    plt.axvline(3.5, color='k', linestyle='--', linewidth=2, label='Domain Wall')
    
    plt.title("B. The Soliton: Particle Trapped at Interface", fontsize=12, fontweight='bold')
    plt.xlabel("Spatial Node Index (0-6)")
    plt.ylabel("Probability Density |Ψ|²")
    plt.legend()

    # PLOT C: ROBUSTNESS SCATTER
    plt.subplot(2, 2, 3)
    y_scatter = np.random.normal(0, 0.02, len(zero_hist))
    
    plt.scatter(zero_hist, y_scatter, color='red', alpha=0.6, s=50, label='Zero Mode (Perturbed)')
    plt.scatter(bulk_hist, y_scatter, color='blue', alpha=0.6, s=50, label='Bulk Mode (Perturbed)')
    
    plt.axvline(0, color='k', linestyle='-', linewidth=1)
    plt.title(f"C. Robustness Test ({noise_amp*100}% Noise)", fontsize=12, fontweight='bold')
    plt.xlabel("Energy Eigenvalue")
    plt.yticks([])
    plt.legend()

    # PLOT D: ADIABATIC SPECTRAL FLOW
    plt.subplot(2, 2, 4)
    # Plot all 14 bands
    for band in range(14):
        # Color the zero modes Red, others Blue
        # Sorting puts zero modes in the middle (indices 6, 7)
        color = 'red' if band in [6, 7] else 'navy'
        alpha = 1.0 if color == 'red' else 0.2
        width = 2.5 if color == 'red' else 1.0
        plt.plot(flow_x, flow_y[:, band], color=color, alpha=alpha, linewidth=width)
        
    plt.axhline(0, color='black', linestyle='--', linewidth=0.5)
    plt.text(0.02, -5, "Topological\n(Domain Wall)", fontweight='bold')
    plt.text(0.98, -5, "Trivial\n(Uniform)", fontweight='bold', ha='right')
    
    plt.title("D. Adiabatic Proof: Gap Must Close to Remove Zero Mode", fontsize=12, fontweight='bold')
    plt.xlabel(r"Adiabatic Parameter $\lambda$")
    plt.ylabel("Energy Spectrum")

    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    run_proof()
